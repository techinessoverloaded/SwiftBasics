**Published by Arunprasadh C on 26 May 2022** • *Last Updated on 31 May 2022*

## Classes in Swift
A Class is considered as a blueprint of objects. In Swift, a Class is similar to a Structure in most of the aspects. However, Swift Classes have the following unique properties and additional capabilities as compared to Structures:
- Classes are **Reference Types** unlike Structures. This means that the Objects of a Class are passed by Reference. Also, ARC allows multiple references of a class instance to exist.
- Classes support Inheritance.
- Classes support Typecasting.
- Classes can have Deinitializers (similar to **C++** Destructors) in addition to Initializers.

Due to the above mentioned capabilities, Classes in Swift can leverage all the benefits of Object-oriented Programming. Classes in Swift are marked by the `class` keyword.

**Syntax :**
```swift
class ClassName
{
   //Class Properties and Methods
}
```

It is similar to `struct` declaration, right ? So, when to choose Class over Structure ?

### Choosing between Classes and Structures
The [Apple Developer Documentation](https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes) suggests the following Recommendations (Quoted from the Documentation):
- **Choose Structures by Default:** Using structures makes it easier to reason about a portion of your code without needing to consider the whole state of your app. Because structures are value types—unlike classes—local changes to a structure aren't visible to the rest of your app unless you intentionally communicate those changes as part of the flow of your app. As a result, you can look at a section of code and be more confident that changes to instances in that section will be made explicitly, rather than being made invisibly from a tangentially related function call. That is why even the Swift Standard Library uses Structures throughout and the usage of Classes is minimalized.

- **Use Classes When You Need Objective-C Interoperability:** If you use an Objective-C API that needs to process your data, or you need to fit your data model into an existing class hierarchy defined in an Objective-C framework, you might need to use classes and class inheritance to model your data. For example, many Objective-C frameworks expose classes that you are expected to subclass.

- **Use Classes When You Need to Control Identity and Structures otherwise:** Classes in Swift come with a built-in notion of identity because they're reference types. This means that when two different class instances have the same value for each of their stored properties, they're still considered to be different by the identity operator (`===`). It also means that when you share a class instance across your app, changes you make to that instance are visible to every part of your code that holds a reference to that instance. Use classes when you need your instances to have this kind of identity. Use structures when you're modeling data that contains information about an entity with an identity that you don't control.

- **Use Structures and Protocols to Model Inheritance and Share Behavior:** Structures and classes both support a form of inheritance. Structures and protocols can only adopt protocols; they can't inherit from classes. However, the kinds of inheritance hierarchies you can build with class inheritance can be also modeled using protocol inheritance and structures. If you're building an inheritance relationship from scratch, prefer protocol inheritance. Protocols permit classes, structures, and enumerations to participate in inheritance, while class inheritance is only compatible with other classes. When you're choosing how to model your data, try building the hierarchy of data types using protocol inheritance first, then adopt those protocols in your structures.

### Object Creation and Accessing Members
Object creation, accessing properties and methods of a `class` and  are all similar to `struct`.

**Example 1:**
```swift
class Student
{
    var rollNo: Int
    var name: String
    
    init(rollNo: Int, name: String)
    {
        self.rollNo = rollNo
        self.name = name
    }
}

let student = Student(rollNo: 1, name: "Kris")
print(student.rollNo)
print(student.name)
print(student)
```
**Output 1:**
```
1
Kris
helloworld.Student
```

You can notice that when I printed the `student` object, I didn't get a standard `String` representation of the object like Structures. This is because `class` in Swift doesn't conform to `CustomStringConvertible` Protocol by default unlike Structures and even this can be attributed to Inheritance because only at runtime, the type of object is decided.

### Initializers
We have already seen about Initializers in [Structures](https://techinessoverloaded.github.io/iOSAppDevBasics/structs.html), but we will see more about them here. For stuctures, memberwise initializers are automatically generated by the compiler. But, for classes the compiler doesn't generate Member-wise initializer on its own, as Classes allow Inheritance and it is difficult for the compiler to decide how the Initializer should be generated. If Initializer is not defined manually for the Class, the code won't compile and the compiler will throw an error `Class 'ClassName' has no initializers`.
However, if all the properties of a class or struct have default values, then a default initializer will be generated even if it is not manually written. 

The **Initializers for Classes** are classified into various types. The general Initializers are called **Designated Initializers** while the Initializers which make the calling of Designated ones easier, are called as **Convenience Initializers** and are marked by the keyword `convenience`. Convenience Initializers are generally used for assigning default values to properties. Designated and Convenience Initializers will be explored in detail while exploring Inheritance. We can also define **Failable Initializers** which can fail and return `nil` instead of an instance. Failable Initializers are defined by marking the `init` keyword with Question Mark `?`, like `init?`. Failable Initializers will always return `Optional` wrapped Instances which have to be unwrapped for further use. When a property needs to be assigned the same initial value all the time, it is advised to give the default value in the property declaration itself, rather than assigning the default value via an initializer.

**Example 2:**
```swift
class Age: CustomStringConvertible
{
    var description: String
    {
        "Age(\(value))"
    }
    
    var value: Int
    
    init?(_ value: Int)
    {
        if value < 0 || value > 100
        {
            print("Invalid Age \(value)! ")
            return nil
        }
        else
        {
            self.value = value
        }
    }
    
    init()
    {
        self.value = Int.random(in: 0...100)
    }
}

for x in [-2, 21, 500]
{
    if let age = Age(x)
    {
        print(age)
    }
    else
    {
        print("As Invalid Age \(x) is provided, randomizing Age Value: \(Age())")
    }
}
```
**Output 2:**
```
Invalid Age -2! 
As Invalid Age -2 is provided, randomizing Age Value: Age(3)
Age(21)
Invalid Age 500! 
As Invalid Age 500 is provided, randomizing Age Value: Age(82)
```

### Deinitializer
In addition to Initializers, Swift Classes can also have a single Deinitializer, which is called just before the Object of the Class is deallocated (Similar to **C++** Destructors). These can be used for performing additional tasks like closing a file or any held resource, thereby freeing up the memory before the class object itself is deallocated. Messages printed inside Deinitializer block can generally be realized when the object is being deallocated.

**Example 3:**
```swift
class Student: CustomStringConvertible
{
    var rollNo: Int
    var name: String
    var description: String
    {
        "Student(rollNo = \(rollNo), name = \(name))"
    }
    
    init(rollNo: Int, name: String)
    {
        self.rollNo = rollNo
        self.name = name
    }
    
    func changeRollNoAndName(newRollNo:Int, newName: String)
    {
        rollNo = newRollNo
        name = newName
    }
    
    deinit
    {
        print("Student: \(name) is being deinitialized...")
    }
}

var student: Student? = Student(rollNo: 1, name: "Kris")
print(student!)
student = nil // Deinitializing the object
let _ = Student(rollNo: 2, name: "Siva") // Using '_' to indicate ignored or unused object. Hence it is deallocated immediately.
```
**Output 3:**
```
Student(rollNo = 1, name = Kris)
Student: Kris is being deinitialized...
Student: Siva is being deinitialized...
```

When `nil` is assigned to the Optional `student` object, it means that it can be deallocated and hence the deinitializer is called. Underscore `_` is used for Wildcard Pattern Matching in Swift. It is used whenever a variable or constant is ignored or unwanted. It is also used when the return type of a function is ignored. It is used in for loops too when the iterating variable can be ignored. In the Above example, the `_` indicates that the object can be ignored or is not going to be used. Hence, the scope of the object gets over as soon as it is created and hence, the deinitializer is called.

### Protocol Conformance
Classes can also conform to Protocols like Structures and use the same syntax as Structures for conforming. We will see more about Protocols in a separate Topic Page.

### Behaviour with `let` Constants
As mentioned earlier in [Structures](https://techinessoverloaded.github.io/iOSAppDevBasics/structs.html), `let` Constants behave differently with Classes. The regular behaviour of preventing reassigning of objects is maintained. However, the properties of Class object can be mutated even when using `let`, as Classes are Reference Types.

**Example 4:**
```swift
class Student: CustomStringConvertible
{
    var rollNo: Int
    var name: String
    var description: String
    {
        "Student(rollNo = \(rollNo), name = \(name))"
    }
    
    init(rollNo: Int, name: String)
    {
        self.rollNo = rollNo
        self.name = name
    }
}
let student = Student(rollNo: 1, name: "Kris")
print(student.description)
print(student.rollNo)
student.name = "Shiv" // Modifying the property of a let constant object
print(student.name)
print(student)
```
**Output 4:**
```
Student(rollNo = 1, name = Kris)
1
Shiv
Student(rollNo = 1, name = Shiv)
```

You can see that the name was changed even though `student` is a `let` constant.

### No need of `mutating` Keyword for Mutating Methods
Unlike `struct`, the Mutating Methods of `class` don't need the `mutating` keyword, as Classes are Reference Types.

**Example 5:**
```swift
class Student: CustomStringConvertible
{
    var rollNo: Int
    var name: String
    var description: String
    {
        "Student(rollNo = \(rollNo), name = \(name))"
    }
    
    init(rollNo: Int, name: String)
    {
        self.rollNo = rollNo
        self.name = name
    }
    
    func changeRollNoAndName(newRollNo:Int, newName: String)
    {
        rollNo = newRollNo
        name = newName
    }
}

let student = Student(rollNo: 1, name: "Kris")
print("Original Value: \(student)")
student.changeRollNoAndName(newRollNo: 2, newName: "Shiv")
print("After calling changeRollNoAndName() Method: \(student)")
```
**Output 5:**
```
Original Value: Student(rollNo = 1, name = Kris)
After calling changeRollNoAndName() Method: Student(rollNo = 2, name = Shiv)
```

### Equality and Identity Logic
Unlike Structures, the Identity Operators (`===` and `!==`) can be used with Classes. Identity Operators compare the memory uniqueness of two class instances. They don't check if the values are equal. They instead check if the two instances point to the same reference in the memory. In order for Equality Operators (`==` and `!=`) to work, the Class has to conform to the `Equatable` Protocol. However, unlike Structures, it is not optional to override the `==` function. It must be redefined inside the class for the equality operators to work. The equality operators don't care about the memory address. They rather care about the properties of the instances.

**Example 6:**
```swift
class Student: CustomStringConvertible, Equatable
{
    var rollNo: Int
    var name: String
    var description: String
    {
        "Student(rollNo = \(rollNo), name = \(name))"
    }

    init(rollNo: Int, name: String)
    {
        self.rollNo = rollNo
        self.name = name
    }

    func changeRollNoAndName(newRollNo:Int, newName: String)
    {
        rollNo = newRollNo
        name = newName
    }
    
    static func == (lhs: Student, rhs: Student) -> Bool
    {
        lhs.name == rhs.name && lhs.rollNo == lhs.rollNo
    }
    
    deinit
    {
        print("Student: \(name) is being deinitialized...")
    }
}

let student1 = Student(rollNo: 1, name: "Kris")
let student2 = student1
let student3 = Student(rollNo: 2, name: "Kris")
print("Student 1: \(student1)")
print("Student 2: \(student2)")
print("Student 3: \(student3)")
print("student1 === student2: \(student1 === student2)")
student2.rollNo = 2 // Changing rollNo of student 2
print("Student 1: \(student1)") // Student 1 rollNo also changed. Call by reference behaviour
print("Student 2: \(student2)")
print("student2 === student3: \(student2 === student3)") // Even though Same value but different reference, so false
print("student2 == student3: \(student2 == student3)") // Even though different reference, same value is present. so == returns true
print("student1 == student2: \(student1 == student2)")
print("student1 == student3: \(student1 == student3)")
let student4 = Student(rollNo: 3, name: "Ram")
print("Student 4: \(student4)")
print("student4 != student1: \(student4 != student1)")// true as rollNo not and Name equal
```
**Output 6:**
```
Student 1: Student(rollNo = 1, name = Kris)
Student 2: Student(rollNo = 1, name = Kris)
Student 3: Student(rollNo = 2, name = Kris)
student1 === student2: true
Student 1: Student(rollNo = 2, name = Kris)
Student 2: Student(rollNo = 2, name = Kris)
student2 === student3: false
student2 == student3: true
student1 == student2: true
student1 == student3: true
Student 4: Student(rollNo = 3, name = Ram)
student4 != student1: true
```

### Inheritance using Classes
Unlike Structures, Classes can inherit properties and methods from one another. The Class which inherits from another class is called as **Subclass/Child Class** and the Class whose members are inherited is called the **Super Class/Parent Class**(It is also known as **Base Class**, if it doesn't inherit from other classes). Classes in Swift can call and access methods, properties, and subscripts belonging to their superclass and can provide their own overriding versions of those methods, properties, and subscripts to refine or modify their behavior. Swift helps to ensure your overrides are correct by checking that the override definition has a matching superclass definition. Classes can also add property observers to inherited properties in order to be notified when the value of a property changes. Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.

#### Is-A Relationship
Inheritance should be used only when there exists an **Is-A** Relationship between Two Classes. For example:
1. **Car** is a **Vehicle**.
2. **Student** is a **Person**.
3. **Dog** is an **Animal**.
Here, **Car** can inherit members from **Vehicle**, **Student** from **Person** and so on.

The Syntax of Inheritance is as follows:
**Syntax :**
```swift
class Subclass : Superclass
{
   //Class Members
}
```

The Colon (`:`) Operator is used to indicate Inheritance (In terms of Swift, we can even compare it with Type Annotations. We can infer that the SubClass is of Superclass `Type`). The `override` keyword is used for overriding the Non-`private` Computed Properties, Methods and even Initializers of the superclass. The `super` keyword is used for accessing the Non-`private` members of the super class from the subclass. Always, the overridden members are given priority when called from the child classes. A simple example is given below:

**Example 7:**
```swift
class Animal: CustomStringConvertible
{
    var description: String
    {
        "Animal(isMammal: \(isMammal))"
    }
    
    var isMammal: Bool
    
    init(isMammal: Bool)
    {
        self.isMammal = isMammal
    }
    
    func makeSound()
    {
        fatalError("This method must be overridden by subclasses for it to work!!!") // Abstract Methods can be implemented like this
    }
}

class Dog: Animal
{
    override var description: String
    {
        "Dog(isMammal: true, isStrayDog: \(isStrayDog))"
    }
    
    var isStrayDog: Bool
    
    override func makeSound()
    {
        print("Woof!!!")
    }
    
    init(isStrayDog: Bool)
    {
        self.isStrayDog = isStrayDog
        super.init(isMammal: true)
    }
}

var animal: Animal = Animal(isMammal: false)
print(animal)
print(type(of: animal))
animal = Dog(isStrayDog: false) // Works since Dog is a subclass of Animal.
animal.makeSound()
print(animal)
print(type(of: animal))
```
**Output 7:**
```
Animal(isMammal: false)
Animal
Woof!!!
Dog(isMammal: true, isStrayDog: false)
Dog
```





<a href="https://techinessoverloaded.github.io/iOSAppDevBasics/index.html">&larr; Back to Index</a>
<br>
<span style="float: left">
<a href="https://techinessoverloaded.github.io/iOSAppDevBasics/structs.html">&larr; Structures</a>
</span>
<span style="float: right">
<a href="https://techinessoverloaded.github.io/iOSAppDevBasics/.html"> &rarr;</a>
</span>
